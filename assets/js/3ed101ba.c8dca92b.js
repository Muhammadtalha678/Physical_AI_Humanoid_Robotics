"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[1600],{8453:(n,e,i)=>{i.d(e,{R:()=>t,x:()=>l});var s=i(6540);const a={},r=s.createContext(a);function t(n){const e=s.useContext(r);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:t(n.components),s.createElement(r.Provider,{value:e},n.children)}},8868:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>o,contentTitle:()=>l,default:()=>m,frontMatter:()=>t,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"week-8-10/sim-to-real-transfer","title":"Sim-to-Real Transfer Techniques","description":"Sim-to-real transfer is the process of transferring knowledge, policies, or models trained in simulation to real-world robotic systems. This section covers techniques to bridge the gap between simulation and reality, enabling effective transfer of learned behaviors.","source":"@site/docs/week-8-10/sim-to-real-transfer.md","sourceDirName":"week-8-10","slug":"/week-8-10/sim-to-real-transfer","permalink":"/Physical-AI-Humanoid-Robotics/docs/week-8-10/sim-to-real-transfer","draft":false,"unlisted":false,"editUrl":"https://github.com/Muhammadtalha678/Physical-AI-Humanoid-Robotics/edit/main/docs/docs/week-8-10/sim-to-real-transfer.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Sim-to-Real Transfer Techniques"},"sidebar":"tutorialSidebar","previous":{"title":"Reinforcement Learning for Robot Control","permalink":"/Physical-AI-Humanoid-Robotics/docs/week-8-10/reinforcement-learning-control"},"next":{"title":"Isaac Platform Assessment: AI Robotics and Simulation","permalink":"/Physical-AI-Humanoid-Robotics/docs/week-8-10/isaac-assessment"}}');var a=i(4848),r=i(8453);const t={sidebar_position:4,title:"Sim-to-Real Transfer Techniques"},l="Sim-to-Real Transfer Techniques",o={},d=[{value:"Understanding the Sim-to-Real Gap",id:"understanding-the-sim-to-real-gap",level:2},{value:"Definition of the Gap",id:"definition-of-the-gap",level:3},{value:"Impact on Performance",id:"impact-on-performance",level:3},{value:"Domain Randomization",id:"domain-randomization",level:2},{value:"Concept and Theory",id:"concept-and-theory",level:3},{value:"Implementation Strategies",id:"implementation-strategies",level:3},{value:"Visual Domain Randomization",id:"visual-domain-randomization",level:3},{value:"Dynamics Randomization",id:"dynamics-randomization",level:3},{value:"Domain Adaptation",id:"domain-adaptation",level:2},{value:"Unsupervised Domain Adaptation",id:"unsupervised-domain-adaptation",level:3},{value:"Supervised Domain Adaptation",id:"supervised-domain-adaptation",level:3},{value:"Example: Domain Adaptation for Vision",id:"example-domain-adaptation-for-vision",level:3},{value:"System Identification",id:"system-identification",level:2},{value:"Parameter Estimation",id:"parameter-estimation",level:3},{value:"Model Correction",id:"model-correction",level:3},{value:"Online System Identification",id:"online-system-identification",level:3},{value:"Reality Gap Minimization",id:"reality-gap-minimization",level:2},{value:"Reducing Visual Differences",id:"reducing-visual-differences",level:3},{value:"Physics Model Improvement",id:"physics-model-improvement",level:3},{value:"Sensor Model Refinement",id:"sensor-model-refinement",level:3},{value:"Learning-Based Transfer Techniques",id:"learning-based-transfer-techniques",level:2},{value:"Meta-Learning for Transfer",id:"meta-learning-for-transfer",level:3},{value:"Few-Shot Adaptation",id:"few-shot-adaptation",level:3},{value:"Imitation Learning with Transfer",id:"imitation-learning-with-transfer",level:3},{value:"Practical Transfer Strategies",id:"practical-transfer-strategies",level:2},{value:"Gradual Domain Transfer",id:"gradual-domain-transfer",level:3},{value:"Robust Control Design",id:"robust-control-design",level:3},{value:"Hybrid Simulation-Reality Training",id:"hybrid-simulation-reality-training",level:3},{value:"NVIDIA Isaac Transfer Tools",id:"nvidia-isaac-transfer-tools",level:2},{value:"Isaac Sim Domain Randomization",id:"isaac-sim-domain-randomization",level:3},{value:"Isaac ROS Integration",id:"isaac-ros-integration",level:3},{value:"Transfer Evaluation and Validation",id:"transfer-evaluation-and-validation",level:2},{value:"Performance Metrics",id:"performance-metrics",level:3},{value:"Validation Techniques",id:"validation-techniques",level:3},{value:"Challenges and Limitations",id:"challenges-and-limitations",level:2},{value:"Technical Challenges",id:"technical-challenges",level:3},{value:"Practical Challenges",id:"practical-challenges",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Simulation Quality",id:"simulation-quality",level:3},{value:"Transfer Strategy",id:"transfer-strategy",level:3},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Code Examples",id:"code-examples",level:2},{value:"Exercises",id:"exercises",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"sim-to-real-transfer-techniques",children:"Sim-to-Real Transfer Techniques"})}),"\n",(0,a.jsx)(e.p,{children:"Sim-to-real transfer is the process of transferring knowledge, policies, or models trained in simulation to real-world robotic systems. This section covers techniques to bridge the gap between simulation and reality, enabling effective transfer of learned behaviors."}),"\n",(0,a.jsx)(e.h2,{id:"understanding-the-sim-to-real-gap",children:"Understanding the Sim-to-Real Gap"}),"\n",(0,a.jsx)(e.h3,{id:"definition-of-the-gap",children:"Definition of the Gap"}),"\n",(0,a.jsx)(e.p,{children:"The sim-to-real gap refers to the differences between simulated and real environments that can cause performance degradation when transferring learned policies:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Visual Differences"}),": Lighting, textures, colors, and visual artifacts"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Physics Discrepancies"}),": Friction, damping, mass properties, and contact models"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Sensor Noise"}),": Differences in sensor readings between simulation and reality"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Actuator Dynamics"}),": Motor response, delays, and control precision differences"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Environmental Factors"}),": Temperature, air resistance, and external disturbances"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"impact-on-performance",children:"Impact on Performance"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Policy Degradation"}),": Learned behaviors may fail in the real world"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Control Instability"}),": Controllers may become unstable with real dynamics"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Perception Errors"}),": Computer vision models may fail on real data"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Task Failure"}),": Complex tasks may become impossible to complete"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"domain-randomization",children:"Domain Randomization"}),"\n",(0,a.jsx)(e.h3,{id:"concept-and-theory",children:"Concept and Theory"}),"\n",(0,a.jsx)(e.p,{children:"Domain randomization involves training in a variety of randomized simulation conditions to improve robustness:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Environmental Randomization"}),": Varying lighting, textures, and object properties"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Dynamics Randomization"}),": Randomizing physical parameters (mass, friction, etc.)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Sensor Randomization"}),": Adding noise and variations to sensor models"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Actuator Randomization"}),": Modeling control delays and precision variations"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"implementation-strategies",children:"Implementation Strategies"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"class DomainRandomizedEnv:\n    def __init__(self):\n        self.param_ranges = {\n            'mass_range': (0.8, 1.2),      # \xb120% mass variation\n            'friction_range': (0.1, 0.9),  # Wide friction range\n            'lighting_range': (0.5, 2.0),  # Brightness variation\n        }\n\n    def randomize_domain(self):\n        \"\"\"Randomize simulation parameters\"\"\"\n        # Randomize physical properties\n        new_mass = np.random.uniform(*self.param_ranges['mass_range'])\n        new_friction = np.random.uniform(*self.param_ranges['friction_range'])\n\n        # Apply to simulation\n        self.simulator.set_mass(new_mass)\n        self.simulator.set_friction(new_friction)\n\n        # Randomize visual properties\n        lighting = np.random.uniform(*self.param_ranges['lighting_range'])\n        self.simulator.set_lighting(lighting)\n\n        return {\n            'mass': new_mass,\n            'friction': new_friction,\n            'lighting': lighting\n        }\n"})}),"\n",(0,a.jsx)(e.h3,{id:"visual-domain-randomization",children:"Visual Domain Randomization"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Texture Randomization"}),": Varying surface textures and materials"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Lighting Variation"}),": Changing light positions, colors, and intensities"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Camera Parameters"}),": Randomizing focal length, distortion, and noise"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Weather Conditions"}),": Simulating different environmental conditions"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"dynamics-randomization",children:"Dynamics Randomization"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Inertial Properties"}),": Mass, center of mass, and moments of inertia"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Contact Properties"}),": Friction coefficients and restitution"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Actuator Models"}),": Delays, noise, and response characteristics"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Environmental Forces"}),": Wind, gravity variations, disturbances"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"domain-adaptation",children:"Domain Adaptation"}),"\n",(0,a.jsx)(e.h3,{id:"unsupervised-domain-adaptation",children:"Unsupervised Domain Adaptation"}),"\n",(0,a.jsx)(e.p,{children:"Techniques for adapting models without labeled real-world data:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Adversarial Training"}),": Training a discriminator to distinguish domains"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Feature Alignment"}),": Aligning feature distributions between domains"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Self-Training"}),": Using real-world unlabeled data to improve models"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"supervised-domain-adaptation",children:"Supervised Domain Adaptation"}),"\n",(0,a.jsx)(e.p,{children:"When some real-world labeled data is available:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Fine-tuning"}),": Adapting pre-trained simulation models"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Multi-domain Training"}),": Joint training on simulation and real data"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Weighted Loss"}),": Balancing simulation and real data importance"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"example-domain-adaptation-for-vision",children:"Example: Domain Adaptation for Vision"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"import torch\nimport torch.nn as nn\n\nclass DomainAdaptationModel(nn.Module):\n    def __init__(self, base_model, num_classes):\n        super().__init__()\n        self.base_model = base_model\n        self.classifier = nn.Linear(512, num_classes)  # Task classifier\n        self.domain_classifier = nn.Linear(512, 2)     # Domain classifier\n\n    def forward(self, x, alpha=0.0):\n        # Extract features\n        features = self.base_model(x)\n\n        # Task prediction\n        class_pred = self.classifier(features)\n\n        # Domain prediction (for adversarial training)\n        # Gradient reversal for domain adaptation\n        reversed_features = GradientReversal.apply(features, alpha)\n        domain_pred = self.domain_classifier(reversed_features)\n\n        return class_pred, domain_pred\n\nclass GradientReversal(torch.autograd.Function):\n    @staticmethod\n    def forward(ctx, input, alpha):\n        ctx.alpha = alpha\n        return input\n\n    @staticmethod\n    def backward(ctx, grad_output):\n        return grad_output.neg() * ctx.alpha, None\n"})}),"\n",(0,a.jsx)(e.h2,{id:"system-identification",children:"System Identification"}),"\n",(0,a.jsx)(e.h3,{id:"parameter-estimation",children:"Parameter Estimation"}),"\n",(0,a.jsx)(e.p,{children:"Identifying real-world parameters to update simulation models:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Maximum Likelihood Estimation"}),": Finding parameters that maximize likelihood"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Bayesian Inference"}),": Incorporating prior knowledge and uncertainty"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Optimization-Based Methods"}),": Minimizing prediction errors"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"model-correction",children:"Model Correction"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Dynamics Correction"}),": Updating physics models based on real data"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Sensor Calibration"}),": Correcting sensor models and biases"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Actuator Modeling"}),": Improving actuator response models"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"online-system-identification",children:"Online System Identification"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'class OnlineSystemID:\n    def __init__(self):\n        self.params = {\'mass\': 1.0, \'friction\': 0.1, \'inertia\': 0.1}\n        self.learning_rate = 0.01\n        self.buffer_size = 1000\n        self.data_buffer = []\n\n    def update_model(self, real_obs, sim_obs, action):\n        """Update model parameters based on real vs sim observations"""\n        # Calculate prediction error\n        error = real_obs - sim_obs\n\n        # Estimate parameter gradients\n        gradients = self.estimate_gradients(action, error)\n\n        # Update parameters\n        for param_name, grad in gradients.items():\n            self.params[param_name] -= self.learning_rate * grad\n\n        # Update simulation with new parameters\n        self.update_simulation_params(self.params)\n\n    def estimate_gradients(self, action, error):\n        """Estimate parameter gradients using finite differences"""\n        gradients = {}\n        for param_name in self.params:\n            # Perturb parameter slightly\n            original_value = self.params[param_name]\n            perturbed_value = original_value + 1e-6\n\n            # Calculate effect on prediction\n            sim_obs_perturbed = self.simulate_with_params(\n                {**self.params, param_name: perturbed_value}, action\n            )\n\n            # Estimate gradient\n            gradient = (sim_obs_perturbed - self.last_sim_obs) / 1e-6\n            gradients[param_name] = np.mean(gradient * error)\n\n        return gradients\n'})}),"\n",(0,a.jsx)(e.h2,{id:"reality-gap-minimization",children:"Reality Gap Minimization"}),"\n",(0,a.jsx)(e.h3,{id:"reducing-visual-differences",children:"Reducing Visual Differences"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Image-to-Image Translation"}),": Using GANs to make simulation images realistic"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Synthetic Data Generation"}),": Creating realistic synthetic datasets"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Style Transfer"}),": Applying real-world styles to simulation images"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"physics-model-improvement",children:"Physics Model Improvement"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Reduced Order Models"}),": Simplifying complex physics while maintaining accuracy"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Hybrid Models"}),": Combining analytical and learned physics models"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Correction Terms"}),": Adding learned corrections to physics models"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"sensor-model-refinement",children:"Sensor Model Refinement"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Noise Modeling"}),": Accurately modeling real sensor noise characteristics"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Latency Simulation"}),": Modeling sensor processing delays"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Calibration"}),": Incorporating real sensor calibration parameters"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"learning-based-transfer-techniques",children:"Learning-Based Transfer Techniques"}),"\n",(0,a.jsx)(e.h3,{id:"meta-learning-for-transfer",children:"Meta-Learning for Transfer"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Model-Agnostic Meta-Learning (MAML)"}),": Learning to adapt quickly"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Reptile"}),": Simple meta-learning algorithm"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Meta-World"}),": Multi-task meta-learning for robotics"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"few-shot-adaptation",children:"Few-Shot Adaptation"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Adaptation Networks"}),": Networks that adapt with few examples"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Online Adaptation"}),": Real-time adaptation during deployment"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Bayesian Adaptation"}),": Uncertainty-aware adaptation"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"imitation-learning-with-transfer",children:"Imitation Learning with Transfer"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Behavioral Cloning"}),": Learning from demonstrations in simulation"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"DAgger"}),": Iterative imitation learning with corrections"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Cross-Domain Imitation"}),": Imitating across different domains"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"practical-transfer-strategies",children:"Practical Transfer Strategies"}),"\n",(0,a.jsx)(e.h3,{id:"gradual-domain-transfer",children:"Gradual Domain Transfer"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Curriculum Learning"}),": Progressively moving from simulation to reality"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Intermediate Domains"}),": Using domains between simulation and reality"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Progressive Un-randomization"}),": Gradually reducing domain randomization"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"robust-control-design",children:"Robust Control Design"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"H-infinity Control"}),": Robust control for uncertain dynamics"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Sliding Mode Control"}),": Control robust to model uncertainties"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Adaptive Control"}),": Controllers that adapt to changing dynamics"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"hybrid-simulation-reality-training",children:"Hybrid Simulation-Reality Training"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"class HybridTrainer:\n    def __init__(self, sim_env, real_env):\n        self.sim_env = sim_env\n        self.real_env = real_env\n        self.sim_ratio = 0.9  # Start with mostly simulation\n        self.real_ratio = 0.1\n\n    def train_step(self):\n        # Collect data from both environments\n        if np.random.random() < self.sim_ratio:\n            # Train on simulation data\n            sim_data = self.sim_env.get_experience()\n            loss = self.train_on_experience(sim_data)\n        else:\n            # Train on real data\n            real_data = self.real_env.get_experience()\n            loss = self.train_on_experience(real_data, real_world=True)\n\n        # Gradually increase real world ratio\n        self.real_ratio = min(0.5, self.real_ratio + 1e-5)\n\n        return loss\n"})}),"\n",(0,a.jsx)(e.h2,{id:"nvidia-isaac-transfer-tools",children:"NVIDIA Isaac Transfer Tools"}),"\n",(0,a.jsx)(e.h3,{id:"isaac-sim-domain-randomization",children:"Isaac Sim Domain Randomization"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Automatic Randomization"}),": Built-in tools for domain randomization"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"USD-Based Randomization"}),": Randomizing Universal Scene Description files"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Parameter Control"}),": Fine-grained control over randomization parameters"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"isaac-ros-integration",children:"Isaac ROS Integration"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Real-Sim Bridge"}),": Seamless integration between real and simulated systems"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Parameter Synchronization"}),": Automatic parameter updates between domains"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Performance Monitoring"}),": Tracking transfer performance metrics"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"transfer-evaluation-and-validation",children:"Transfer Evaluation and Validation"}),"\n",(0,a.jsx)(e.h3,{id:"performance-metrics",children:"Performance Metrics"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Success Rate"}),": Percentage of successful task completions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Task Completion Time"}),": Time to complete tasks in both domains"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Control Stability"}),": Stability of control policies in reality"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Generalization"}),": Performance on unseen real-world scenarios"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"validation-techniques",children:"Validation Techniques"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"A/B Testing"}),": Comparing simulation vs. real-world performance"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Statistical Tests"}),": Validating performance differences"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Safety Validation"}),": Ensuring safe behavior in reality"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Long-term Stability"}),": Testing over extended periods"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"challenges-and-limitations",children:"Challenges and Limitations"}),"\n",(0,a.jsx)(e.h3,{id:"technical-challenges",children:"Technical Challenges"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Model Mismatch"}),": Inability to perfectly model real-world dynamics"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Computational Cost"}),": High cost of domain randomization"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Data Requirements"}),": Need for extensive real-world data"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Convergence Issues"}),": Difficulty in training stable policies"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"practical-challenges",children:"Practical Challenges"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Hardware Safety"}),": Protecting real hardware during transfer"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Time Constraints"}),": Limited time for real-world training"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Maintenance"}),": Keeping simulation models up-to-date"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Scalability"}),": Applying to diverse robotic platforms"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(e.h3,{id:"simulation-quality",children:"Simulation Quality"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Accurate Physics"}),": Use high-fidelity physics engines"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Realistic Sensors"}),": Model sensors with realistic noise and delays"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Hardware Fidelity"}),": Accurately model robot hardware characteristics"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Environmental Accuracy"}),": Include relevant environmental factors"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"transfer-strategy",children:"Transfer Strategy"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Start Simple"}),": Begin with simple tasks and gradually increase complexity"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Monitor Performance"}),": Continuously monitor transfer performance"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Iterative Refinement"}),": Continuously improve simulation models"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Safety First"}),": Implement safety mechanisms during transfer"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,a.jsx)(e.p,{children:"After completing this section, you should be able to:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Understand the causes and effects of the sim-to-real gap"}),"\n",(0,a.jsx)(e.li,{children:"Implement domain randomization techniques for robust learning"}),"\n",(0,a.jsx)(e.li,{children:"Apply domain adaptation methods to bridge simulation and reality"}),"\n",(0,a.jsx)(e.li,{children:"Design effective transfer strategies for robot control tasks"}),"\n",(0,a.jsx)(e.li,{children:"Evaluate and validate sim-to-real transfer performance"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,a.jsx)(e.p,{children:"Refer to the following code examples in the textbook repository:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"docs/static/code-examples/isaac-examples/rl_cartpole_example.py"})," - Example of training in simulation with potential for sim-to-real transfer"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"docs/static/code-examples/isaac-examples/simple_isaac_example.py"})," - Isaac Sim environment setup that can be used for domain randomization"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Implement domain randomization in a simple robotic simulation environment"}),"\n",(0,a.jsx)(e.li,{children:"Design a system identification experiment to update simulation parameters"}),"\n",(0,a.jsx)(e.li,{children:"Compare the performance of a policy trained with and without domain randomization"}),"\n",(0,a.jsx)(e.li,{children:"Create a curriculum for gradually transferring a learned policy from simulation to a real robot"}),"\n",(0,a.jsx)(e.li,{children:"Experiment with the provided examples to understand domain randomization techniques"}),"\n"]})]})}function m(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(c,{...n})}):c(n)}}}]);