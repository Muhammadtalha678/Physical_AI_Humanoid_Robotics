"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[8973],{2605:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"week-11-12/bipedal-locomotion","title":"Bipedal Locomotion and Balance Control","description":"Bipedal locomotion is one of the most challenging aspects of humanoid robotics, requiring sophisticated control strategies to achieve stable and efficient walking patterns. This section covers the principles of bipedal gait generation, balance control, and stability maintenance.","source":"@site/docs/week-11-12/bipedal-locomotion.md","sourceDirName":"week-11-12","slug":"/week-11-12/bipedal-locomotion","permalink":"/Physical-AI-Humanoid-Robotics/docs/week-11-12/bipedal-locomotion","draft":false,"unlisted":false,"editUrl":"https://github.com/Muhammadtalha678/Physical-AI-Humanoid-Robotics/edit/main/docs/docs/week-11-12/bipedal-locomotion.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Bipedal Locomotion and Balance Control"},"sidebar":"tutorialSidebar","previous":{"title":"Humanoid Robot Kinematics and Dynamics","permalink":"/Physical-AI-Humanoid-Robotics/docs/week-11-12/humanoid-kinematics-dynamics"},"next":{"title":"Manipulation and Grasping with Humanoid Hands","permalink":"/Physical-AI-Humanoid-Robotics/docs/week-11-12/manipulation-grasping"}}');var i=t(4848),r=t(8453);const a={sidebar_position:2,title:"Bipedal Locomotion and Balance Control"},l="Bipedal Locomotion and Balance Control",s={},c=[{value:"Fundamentals of Bipedal Locomotion",id:"fundamentals-of-bipedal-locomotion",level:2},{value:"Gait Phases",id:"gait-phases",level:3},{value:"Walking Pattern Generation",id:"walking-pattern-generation",level:3},{value:"Footstep Planning",id:"footstep-planning",level:4},{value:"Trajectory Generation",id:"trajectory-generation",level:4},{value:"Balance Control Strategies",id:"balance-control-strategies",level:2},{value:"Center of Mass Control",id:"center-of-mass-control",level:3},{value:"Capture Point Control",id:"capture-point-control",level:3},{value:"Linear Inverted Pendulum Mode (LIPM)",id:"linear-inverted-pendulum-mode-lipm",level:3},{value:"Walking Pattern Generators",id:"walking-pattern-generators",level:2},{value:"Preview Control",id:"preview-control",level:3},{value:"Stability Analysis",id:"stability-analysis",level:2},{value:"Zero Moment Point (ZMP) Stability",id:"zero-moment-point-zmp-stability",level:3},{value:"Advanced Control Techniques",id:"advanced-control-techniques",level:2},{value:"Model Predictive Control (MPC)",id:"model-predictive-control-mpc",level:3},{value:"Whole-Body Control",id:"whole-body-control",level:3},{value:"Practical Implementation Considerations",id:"practical-implementation-considerations",level:2},{value:"Sensor Integration",id:"sensor-integration",level:3},{value:"Real-time Performance",id:"real-time-performance",level:3},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Code Examples",id:"code-examples",level:2},{value:"Exercises",id:"exercises",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"bipedal-locomotion-and-balance-control",children:"Bipedal Locomotion and Balance Control"})}),"\n",(0,i.jsx)(n.p,{children:"Bipedal locomotion is one of the most challenging aspects of humanoid robotics, requiring sophisticated control strategies to achieve stable and efficient walking patterns. This section covers the principles of bipedal gait generation, balance control, and stability maintenance."}),"\n",(0,i.jsx)(n.h2,{id:"fundamentals-of-bipedal-locomotion",children:"Fundamentals of Bipedal Locomotion"}),"\n",(0,i.jsx)(n.h3,{id:"gait-phases",children:"Gait Phases"}),"\n",(0,i.jsx)(n.p,{children:"Bipedal walking consists of several distinct phases:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Double Support Phase"}),": Both feet are in contact with the ground"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Single Support Phase"}),": Only one foot is in contact with the ground"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Swing Phase"}),": The non-support leg moves forward"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Contact Phase"}),": The swing foot makes contact with the ground"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Understanding these phases is crucial for generating stable walking patterns."}),"\n",(0,i.jsx)(n.h3,{id:"walking-pattern-generation",children:"Walking Pattern Generation"}),"\n",(0,i.jsx)(n.h4,{id:"footstep-planning",children:"Footstep Planning"}),"\n",(0,i.jsx)(n.p,{children:"Footstep planning determines where and when the feet should be placed:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import numpy as np\nfrom scipy.spatial.transform import Rotation as R\n\nclass FootstepPlanner:\n    def __init__(self, step_length=0.3, step_width=0.2, step_height=0.05):\n        self.step_length = step_length\n        self.step_width = step_width\n        self.step_height = step_height\n\n    def plan_footsteps(self, start_pos, goal_pos, num_steps):\n        \"\"\"\n        Plan a sequence of footsteps from start to goal\n        \"\"\"\n        footsteps = []\n\n        # Calculate direction vector\n        direction = goal_pos[:2] - start_pos[:2]\n        distance = np.linalg.norm(direction)\n\n        if distance == 0:\n            return footsteps\n\n        direction = direction / distance  # Normalize\n\n        # Generate footsteps\n        current_pos = start_pos.copy()\n\n        for i in range(num_steps):\n            # Alternate between left and right foot\n            if i % 2 == 0:  # Left foot\n                lateral_offset = np.array([-self.step_width/2, 0])\n            else:  # Right foot\n                lateral_offset = np.array([self.step_width/2, 0])\n\n            # Rotate lateral offset based on walking direction\n            rotation_matrix = np.array([\n                [direction[0], -direction[1]],\n                [direction[1], direction[0]]\n            ])\n            offset = rotation_matrix @ lateral_offset\n\n            # Calculate foot position\n            foot_pos = current_pos[:2] + direction * self.step_length * (i + 1) + offset\n            foot_yaw = np.arctan2(direction[1], direction[0])\n\n            footsteps.append({\n                'position': np.append(foot_pos, current_pos[2]),\n                'yaw': foot_yaw,\n                'step_number': i + 1,\n                'support_leg': 'left' if i % 2 == 0 else 'right'\n            })\n\n        return footsteps\n"})}),"\n",(0,i.jsx)(n.h4,{id:"trajectory-generation",children:"Trajectory Generation"}),"\n",(0,i.jsx)(n.p,{children:"Generating smooth trajectories for the feet and center of mass:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def generate_foot_trajectory(foot_pos, lift_height=0.05, step_time=1.0, dt=0.01):\n    """\n    Generate a smooth trajectory for a foot movement\n    """\n    # Time parameters\n    lift_time = step_time * 0.2  # 20% of time for lifting\n    move_time = step_time * 0.6  # 60% of time for moving\n    place_time = step_time * 0.2  # 20% of time for placing\n\n    # Calculate trajectory points\n    trajectory = []\n    t = 0\n\n    # Pre-lift phase (if starting from ground)\n    start_pos = foot_pos - np.array([0, 0, lift_height/2])  # Start slightly raised\n\n    while t <= step_time:\n        if t < lift_time:\n            # Lift phase - parabolic lift\n            progress = t / lift_time\n            height = start_pos[2] + lift_height * (1 - np.cos(np.pi * progress)) / 2\n            pos = start_pos + np.array([0, 0, height - start_pos[2]])\n        elif t < lift_time + move_time:\n            # Move phase - linear movement with constant height\n            progress = (t - lift_time) / move_time\n            pos = start_pos + np.array([0, 0, lift_height]) + \\\n                  (foot_pos - start_pos - np.array([0, 0, lift_height])) * progress\n        else:\n            # Place phase - parabolic lowering\n            progress = (t - lift_time - move_time) / place_time\n            height = lift_height * (1 - np.cos(np.pi * progress)) / 2\n            pos = foot_pos + np.array([0, 0, height])\n\n        trajectory.append(pos.copy())\n        t += dt\n\n    return np.array(trajectory)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"balance-control-strategies",children:"Balance Control Strategies"}),"\n",(0,i.jsx)(n.h3,{id:"center-of-mass-control",children:"Center of Mass Control"}),"\n",(0,i.jsx)(n.p,{children:"Maintaining the center of mass within the support polygon is fundamental for balance:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class BalanceController:\n    def __init__(self, com_height=0.8, control_gain=10.0):\n        self.com_height = com_height\n        self.k = np.sqrt(9.81 / com_height)  # Pendulum frequency\n        self.control_gain = control_gain\n\n    def calculate_balance_correction(self, current_com, desired_com, com_velocity):\n        """\n        Calculate balance correction based on CoM deviation\n        """\n        # Calculate error\n        com_error = desired_com - current_com\n\n        # Apply control law (simplified)\n        correction = self.control_gain * com_error - 2 * np.sqrt(self.control_gain) * com_velocity\n\n        return correction\n'})}),"\n",(0,i.jsx)(n.h3,{id:"capture-point-control",children:"Capture Point Control"}),"\n",(0,i.jsx)(n.p,{children:"The capture point is where the robot would need to step to come to a complete stop:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def calculate_capture_point(com_position, com_velocity, gravity=9.81):\n    """\n    Calculate the capture point for stopping the robot\n    """\n    com_height = com_position[2]\n    omega = np.sqrt(gravity / com_height)\n\n    capture_point = com_position[:2] + com_velocity[:2] / omega\n\n    return capture_point\n\ndef capture_point_controller(current_com, current_vel, target_capture_point, dt):\n    """\n    Control the robot to reach a target capture point\n    """\n    # Calculate current capture point\n    current_capture = calculate_capture_point(current_com, current_vel)\n\n    # Calculate required step location\n    step_location = target_capture_point\n\n    return step_location\n'})}),"\n",(0,i.jsx)(n.h3,{id:"linear-inverted-pendulum-mode-lipm",children:"Linear Inverted Pendulum Mode (LIPM)"}),"\n",(0,i.jsx)(n.p,{children:"The LIPM is a common model for humanoid walking:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class LIPMController:\n    def __init__(self, com_height=0.8, dt=0.01):\n        self.com_height = com_height\n        self.omega = np.sqrt(9.81 / com_height)\n        self.dt = dt\n\n    def update(self, current_com, current_vel, zmp_reference):\n        """\n        Update CoM position and velocity based on ZMP reference\n        """\n        # LIPM dynamics: com\'\' = omega^2 * (com - zmp)\n        com_acc = self.omega**2 * (current_com - zmp_reference)\n\n        # Integrate to get new position and velocity\n        new_vel = current_vel + com_acc * self.dt\n        new_com = current_com + new_vel * self.dt\n\n        return new_com, new_vel\n'})}),"\n",(0,i.jsx)(n.h2,{id:"walking-pattern-generators",children:"Walking Pattern Generators"}),"\n",(0,i.jsx)(n.h3,{id:"preview-control",children:"Preview Control"}),"\n",(0,i.jsx)(n.p,{children:"Preview control uses future reference information to generate stable walking patterns:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class PreviewController:\n    def __init__(self, preview_steps=20, dt=0.01):\n        self.preview_steps = preview_steps\n        self.dt = dt\n\n    def generate_zmp_trajectory(self, start_pos, goal_pos, step_length=0.3):\n        """\n        Generate ZMP trajectory with preview control\n        """\n        # Simplified implementation - in practice, this would involve\n        # solving Riccati equations for optimal control\n        num_steps = int(np.linalg.norm(goal_pos - start_pos) / step_length)\n\n        # Generate ZMP reference based on desired walking pattern\n        zmp_trajectory = []\n        for i in range(self.preview_steps):\n            # Calculate ZMP position based on desired foot placement\n            t = i * self.dt\n            zmp_x = start_pos[0] + (goal_pos[0] - start_pos[0]) * (t / (self.preview_steps * self.dt))\n            zmp_y = start_pos[1] + (goal_pos[1] - start_pos[1]) * (t / (self.preview_steps * self.dt))\n            zmp_trajectory.append([zmp_x, zmp_y])\n\n        return np.array(zmp_trajectory)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"stability-analysis",children:"Stability Analysis"}),"\n",(0,i.jsx)(n.h3,{id:"zero-moment-point-zmp-stability",children:"Zero Moment Point (ZMP) Stability"}),"\n",(0,i.jsx)(n.p,{children:"ZMP-based stability analysis is fundamental for bipedal robots:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def check_zmp_stability(zmp_position, support_polygon):\n    \"\"\"\n    Check if ZMP is within the support polygon\n    \"\"\"\n    # Simplified check for rectangular support polygon\n    min_x, max_x = support_polygon['x_range']\n    min_y, max_y = support_polygon['y_range']\n\n    return min_x <= zmp_position[0] <= max_x and min_y <= zmp_position[1] <= max_y\n\ndef calculate_support_polygon(foot_positions):\n    \"\"\"\n    Calculate support polygon from foot positions\n    \"\"\"\n    if len(foot_positions) == 1:\n        # Single support - small polygon around foot\n        foot = foot_positions[0]\n        margin = 0.05  # 5cm margin\n        return {\n            'x_range': [foot[0] - margin, foot[0] + margin],\n            'y_range': [foot[1] - margin, foot[1] + margin]\n        }\n    else:\n        # Double support - polygon encompassing both feet\n        all_x = [pos[0] for pos in foot_positions]\n        all_y = [pos[1] for pos in foot_positions]\n        return {\n            'x_range': [min(all_x), max(all_x)],\n            'y_range': [min(all_y), max(all_y)]\n        }\n"})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-control-techniques",children:"Advanced Control Techniques"}),"\n",(0,i.jsx)(n.h3,{id:"model-predictive-control-mpc",children:"Model Predictive Control (MPC)"}),"\n",(0,i.jsx)(n.p,{children:"MPC is effective for humanoid balance control:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def model_predictive_balance_control(current_state, reference_trajectory,\n                                   prediction_horizon=10, dt=0.01):\n    """\n    Simplified MPC for balance control\n    """\n    # This would typically involve solving an optimization problem\n    # For this example, we\'ll use a simplified approach\n\n    # Predict future states based on current control\n    predicted_states = []\n    current = current_state.copy()\n\n    for i in range(prediction_horizon):\n        # Apply simple control law\n        error = reference_trajectory[i] - current\n        control_input = 10.0 * error  # Simple proportional control\n\n        # Update state (simplified dynamics)\n        current += control_input * dt\n        predicted_states.append(current.copy())\n\n    return np.array(predicted_states)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"whole-body-control",children:"Whole-Body Control"}),"\n",(0,i.jsx)(n.p,{children:"Integrating balance with full-body motion:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class WholeBodyController:\n    def __init__(self):\n        self.balance_controller = BalanceController()\n        self.ik_solver = InverseKinematicsSolver()  # Assumed implementation\n\n    def compute_control(self, desired_com, desired_feet_pos, current_state):\n        """\n        Compute full-body control commands\n        """\n        # Balance control\n        balance_correction = self.balance_controller.calculate_balance_correction(\n            current_state[\'com\'], desired_com, current_state[\'com_vel\']\n        )\n\n        # Foot placement control\n        desired_foot_positions = self.plan_foot_positions(\n            desired_com, desired_feet_pos, current_state\n        )\n\n        # Inverse kinematics for full body\n        joint_commands = self.ik_solver.solve(\n            desired_com, desired_foot_positions, current_state\n        )\n\n        return joint_commands, balance_correction\n\n    def plan_foot_positions(self, desired_com, desired_feet_pos, current_state):\n        """\n        Plan foot positions considering balance and desired motion\n        """\n        # Combine balance requirements with desired foot positions\n        capture_point = calculate_capture_point(\n            current_state[\'com\'], current_state[\'com_vel\']\n        )\n\n        # Adjust foot positions based on balance requirements\n        adjusted_feet_pos = desired_feet_pos.copy()\n        # Add balance correction logic here\n\n        return adjusted_feet_pos\n'})}),"\n",(0,i.jsx)(n.h2,{id:"practical-implementation-considerations",children:"Practical Implementation Considerations"}),"\n",(0,i.jsx)(n.h3,{id:"sensor-integration",children:"Sensor Integration"}),"\n",(0,i.jsx)(n.p,{children:"Balance control requires integration of multiple sensors:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"IMU"}),": Provides orientation and angular velocity"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Force/Torque sensors"}),": Measure ground reaction forces"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Joint encoders"}),": Provide joint position feedback"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Vision systems"}),": For external reference and obstacle detection"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"real-time-performance",children:"Real-time Performance"}),"\n",(0,i.jsx)(n.p,{children:"Bipedal control requires real-time performance:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Control loops typically run at 200-1000 Hz"}),"\n",(0,i.jsx)(n.li,{children:"Prediction and planning must be computationally efficient"}),"\n",(0,i.jsx)(n.li,{children:"Robust error handling for sensor failures"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(n.p,{children:"After completing this section, you should be able to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Understand the phases of bipedal locomotion"}),"\n",(0,i.jsx)(n.li,{children:"Implement footstep planning algorithms"}),"\n",(0,i.jsx)(n.li,{children:"Design balance control systems using ZMP and capture point"}),"\n",(0,i.jsx)(n.li,{children:"Apply advanced control techniques like MPC to humanoid robots"}),"\n",(0,i.jsx)(n.li,{children:"Integrate sensor feedback for stable walking"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,i.jsx)(n.p,{children:"Refer to the following code examples in the textbook repository:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"docs/static/code-examples/capstone/humanoid_capstone_template.py"})," - Template for humanoid robot integration"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Implement a footstep planner for a humanoid robot"}),"\n",(0,i.jsx)(n.li,{children:"Create a simple ZMP-based balance controller"}),"\n",(0,i.jsx)(n.li,{children:"Generate walking trajectories using the inverted pendulum model"}),"\n",(0,i.jsx)(n.li,{children:"Design a capture point controller for stopping the robot"}),"\n",(0,i.jsx)(n.li,{children:"Integrate sensor feedback into a balance control system"}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var o=t(6540);const i={},r=o.createContext(i);function a(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);