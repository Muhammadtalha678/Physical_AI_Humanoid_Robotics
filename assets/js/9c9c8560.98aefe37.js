"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[6032],{409:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>c,contentTitle:()=>r,default:()=>m,frontMatter:()=>s,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"week-11-12/humanoid-kinematics-dynamics","title":"Humanoid Robot Kinematics and Dynamics","description":"This section covers the mathematical foundations and physical principles governing the movement and forces in humanoid robots. Understanding kinematics and dynamics is essential for controlling the complex multi-link structures of humanoid robots.","source":"@site/docs/week-11-12/humanoid-kinematics-dynamics.md","sourceDirName":"week-11-12","slug":"/week-11-12/humanoid-kinematics-dynamics","permalink":"/Physical-AI-Humanoid-Robotics/docs/week-11-12/humanoid-kinematics-dynamics","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/week-11-12/humanoid-kinematics-dynamics.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Humanoid Robot Kinematics and Dynamics"},"sidebar":"tutorialSidebar","previous":{"title":"Isaac Platform Assessment: AI Robotics and Simulation","permalink":"/Physical-AI-Humanoid-Robotics/docs/week-8-10/isaac-assessment"},"next":{"title":"Bipedal Locomotion and Balance Control","permalink":"/Physical-AI-Humanoid-Robotics/docs/week-11-12/bipedal-locomotion"}}');var a=i(4848),t=i(8453);const s={sidebar_position:1,title:"Humanoid Robot Kinematics and Dynamics"},r="Humanoid Robot Kinematics and Dynamics",c={},l=[{value:"Introduction to Humanoid Kinematics",id:"introduction-to-humanoid-kinematics",level:2},{value:"Forward Kinematics",id:"forward-kinematics",level:3},{value:"Inverse Kinematics",id:"inverse-kinematics",level:3},{value:"Kinematic Chains in Humanoid Robots",id:"kinematic-chains-in-humanoid-robots",level:3},{value:"Humanoid Dynamics",id:"humanoid-dynamics",level:2},{value:"Rigid Body Dynamics",id:"rigid-body-dynamics",level:3},{value:"Center of Mass and Stability",id:"center-of-mass-and-stability",level:3},{value:"Zero Moment Point (ZMP)",id:"zero-moment-point-zmp",level:3},{value:"Walking Patterns and Gait Generation",id:"walking-patterns-and-gait-generation",level:2},{value:"Inverted Pendulum Model",id:"inverted-pendulum-model",level:3},{value:"Control Strategies",id:"control-strategies",level:2},{value:"Operational Space Control",id:"operational-space-control",level:3},{value:"Humanoid-Specific Considerations",id:"humanoid-specific-considerations",level:2},{value:"Underactuation and Balance",id:"underactuation-and-balance",level:3},{value:"Redundancy Resolution",id:"redundancy-resolution",level:3},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Related Content",id:"related-content",level:2},{value:"Code Examples",id:"code-examples",level:2},{value:"Exercises",id:"exercises",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"humanoid-robot-kinematics-and-dynamics",children:"Humanoid Robot Kinematics and Dynamics"})}),"\n",(0,a.jsx)(e.p,{children:"This section covers the mathematical foundations and physical principles governing the movement and forces in humanoid robots. Understanding kinematics and dynamics is essential for controlling the complex multi-link structures of humanoid robots."}),"\n",(0,a.jsx)(e.h2,{id:"introduction-to-humanoid-kinematics",children:"Introduction to Humanoid Kinematics"}),"\n",(0,a.jsx)(e.h3,{id:"forward-kinematics",children:"Forward Kinematics"}),"\n",(0,a.jsx)(e.p,{children:"Forward kinematics determines the position and orientation of the end-effector given the joint angles. For humanoid robots, this involves complex kinematic chains with multiple degrees of freedom."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom scipy.spatial.transform import Rotation as R\n\ndef forward_kinematics(joint_angles, link_lengths):\n    """\n    Calculate forward kinematics for a simplified humanoid arm\n    """\n    # Base position\n    position = np.array([0.0, 0.0, 0.0])\n\n    # Calculate transformation matrices for each joint\n    for i, angle in enumerate(joint_angles):\n        # Rotation matrix for this joint\n        rotation = R.from_euler(\'z\', angle).as_matrix()\n\n        # Translation along the link\n        translation = np.array([link_lengths[i], 0, 0])\n\n        # Apply transformation\n        position = rotation @ position + translation\n\n    return position\n'})}),"\n",(0,a.jsx)(e.h3,{id:"inverse-kinematics",children:"Inverse Kinematics"}),"\n",(0,a.jsx)(e.p,{children:"Inverse kinematics solves for the joint angles required to achieve a desired end-effector position and orientation. This is particularly challenging for humanoid robots due to redundancy and multiple solutions."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'def inverse_kinematics_2d(target_pos, l1, l2):\n    """\n    Solve inverse kinematics for a 2D planar arm\n    """\n    x, y = target_pos\n\n    # Distance from base to target\n    r = np.sqrt(x**2 + y**2)\n\n    # Check if target is reachable\n    if r > l1 + l2:\n        return None  # Target out of reach\n\n    if r < abs(l1 - l2):\n        return None  # Target too close\n\n    # Calculate joint angles\n    cos_theta2 = (l1**2 + l2**2 - r**2) / (2*l1*l2)\n    theta2 = np.arccos(np.clip(cos_theta2, -1, 1))\n\n    k1 = l1 + l2 * np.cos(theta2)\n    k2 = l2 * np.sin(theta2)\n\n    theta1 = np.arctan2(y, x) - np.arctan2(k2, k1)\n\n    return np.array([theta1, theta2])\n'})}),"\n",(0,a.jsx)(e.h3,{id:"kinematic-chains-in-humanoid-robots",children:"Kinematic Chains in Humanoid Robots"}),"\n",(0,a.jsx)(e.p,{children:"Humanoid robots have multiple kinematic chains:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Leg chains"}),": From hip to foot for each leg"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Arm chains"}),": From shoulder to hand for each arm"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Spine chain"}),": Connecting the torso segments"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Head chain"}),": From neck to head"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"Each chain has specific constraints and degrees of freedom that must be considered during motion planning."}),"\n",(0,a.jsx)(e.h2,{id:"humanoid-dynamics",children:"Humanoid Dynamics"}),"\n",(0,a.jsx)(e.h3,{id:"rigid-body-dynamics",children:"Rigid Body Dynamics"}),"\n",(0,a.jsx)(e.p,{children:"The dynamics of humanoid robots are governed by the Newton-Euler or Lagrangian equations. For complex multi-link systems, the equations become:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"M(q)q'' + C(q,q')q' + G(q) = \u03c4\n"})}),"\n",(0,a.jsx)(e.p,{children:"Where:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"M(q) is the mass matrix"}),"\n",(0,a.jsx)(e.li,{children:"C(q,q') contains Coriolis and centrifugal terms"}),"\n",(0,a.jsx)(e.li,{children:"G(q) is the gravity vector"}),"\n",(0,a.jsx)(e.li,{children:"\u03c4 is the joint torque vector"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"center-of-mass-and-stability",children:"Center of Mass and Stability"}),"\n",(0,a.jsx)(e.p,{children:"Maintaining balance is critical for humanoid robots. The center of mass (CoM) must be kept within the support polygon defined by the feet."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'def calculate_com(robot_state, link_masses, link_positions):\n    """\n    Calculate center of mass for the robot\n    """\n    total_mass = sum(link_masses)\n    com = np.zeros(3)\n\n    for mass, pos in zip(link_masses, link_positions):\n        com += mass * pos\n\n    return com / total_mass\n\ndef is_stable(com_position, foot_positions):\n    """\n    Check if the robot is stable based on CoM position\n    """\n    # Calculate support polygon (simplified to bounding box)\n    min_x = min(foot_positions[:, 0])\n    max_x = max(foot_positions[:, 0])\n    min_y = min(foot_positions[:, 1])\n    max_y = max(foot_positions[:, 1])\n\n    # Check if CoM is within support polygon\n    return min_x <= com_position[0] <= max_x and min_y <= com_position[1] <= max_y\n'})}),"\n",(0,a.jsx)(e.h3,{id:"zero-moment-point-zmp",children:"Zero Moment Point (ZMP)"}),"\n",(0,a.jsx)(e.p,{children:"The ZMP is a critical concept for humanoid balance:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'def calculate_zmp(com_position, com_acceleration, gravity=9.81):\n    """\n    Calculate Zero Moment Point\n    """\n    x_com, y_com, z_com = com_position\n    x_acc, y_acc, z_acc = com_acceleration\n\n    zmp_x = x_com - (z_com - 0.0) * x_acc / gravity  # Assuming foot height is 0\n    zmp_y = y_com - (z_com - 0.0) * y_acc / gravity\n\n    return np.array([zmp_x, zmp_y])\n'})}),"\n",(0,a.jsx)(e.h2,{id:"walking-patterns-and-gait-generation",children:"Walking Patterns and Gait Generation"}),"\n",(0,a.jsx)(e.h3,{id:"inverted-pendulum-model",children:"Inverted Pendulum Model"}),"\n",(0,a.jsx)(e.p,{children:"The linear inverted pendulum model (LIPM) is commonly used for humanoid walking:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'def lipm_walking_pattern(com_height, omega, initial_pos, target_pos, dt):\n    """\n    Generate walking pattern using Linear Inverted Pendulum Model\n    """\n    z_com = com_height\n    k = omega  # sqrt(g / z_com)\n\n    # Calculate ZMP trajectory\n    zmp_trajectory = []\n    com_trajectory = []\n\n    # Simple implementation for single step\n    current_pos = np.array(initial_pos)\n    step_size = 0.3  # 30cm step\n    step_duration = 1.0  # 1 second per step\n\n    for t in np.arange(0, step_duration, dt):\n        # ZMP moves to next foot position\n        zmp_pos = current_pos + (target_pos - current_pos) * (t / step_duration)\n        zmp_trajectory.append(zmp_pos)\n\n        # Calculate CoM position based on ZMP\n        com_x = zmp_pos[0] + (z_com / 9.81) * (k**2 * (current_pos[0] - zmp_pos[0]))\n        com_y = zmp_pos[1] + (z_com / 9.81) * (k**2 * (current_pos[1] - zmp_pos[1]))\n\n        com_trajectory.append([com_x, com_y, z_com])\n\n    return np.array(zmp_trajectory), np.array(com_trajectory)\n'})}),"\n",(0,a.jsx)(e.h2,{id:"control-strategies",children:"Control Strategies"}),"\n",(0,a.jsx)(e.h3,{id:"operational-space-control",children:"Operational Space Control"}),"\n",(0,a.jsx)(e.p,{children:"Operational space control allows for direct control of end-effector forces and positions:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'def operational_space_control(robot_state, desired_pose, jacobian, mass_matrix):\n    """\n    Implement operational space control\n    """\n    # Calculate operational space mass matrix\n    lambda_op = np.linalg.inv(jacobian @ np.linalg.inv(mass_matrix) @ jacobian.T)\n\n    # Calculate desired operational space acceleration\n    pose_error = desired_pose - current_pose  # Simplified\n    desired_acc = kp * pose_error + kd * velocity_error  # Simplified\n\n    # Calculate joint torques\n    tau = jacobian.T @ (lambda_op @ desired_acc) + gravity_compensation\n\n    return tau\n'})}),"\n",(0,a.jsx)(e.h2,{id:"humanoid-specific-considerations",children:"Humanoid-Specific Considerations"}),"\n",(0,a.jsx)(e.h3,{id:"underactuation-and-balance",children:"Underactuation and Balance"}),"\n",(0,a.jsx)(e.p,{children:"Humanoid robots are typically underactuated systems where the number of actuators is less than the degrees of freedom in the system. This requires special control strategies:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Passive dynamics"}),": Using the natural dynamics of the system"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Limit cycle control"}),": Creating stable periodic motions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Feedback linearization"}),": Linearizing the nonlinear dynamics"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"redundancy-resolution",children:"Redundancy Resolution"}),"\n",(0,a.jsx)(e.p,{children:"With multiple degrees of freedom, humanoid robots have redundant solutions for reaching the same configuration. Common approaches include:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Null space projection"}),": Optimizing secondary objectives while achieving primary tasks"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Pseudoinverse methods"}),": Finding minimum norm solutions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Task prioritization"}),": Handling multiple simultaneous tasks"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,a.jsx)(e.p,{children:"After completing this section, you should be able to:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Understand forward and inverse kinematics for humanoid robots"}),"\n",(0,a.jsx)(e.li,{children:"Apply dynamics principles to analyze humanoid robot motion"}),"\n",(0,a.jsx)(e.li,{children:"Calculate center of mass and stability metrics"}),"\n",(0,a.jsx)(e.li,{children:"Implement basic walking pattern generation algorithms"}),"\n",(0,a.jsx)(e.li,{children:"Design operational space controllers for humanoid robots"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"related-content",children:"Related Content"}),"\n",(0,a.jsx)(e.p,{children:"For deeper understanding of related concepts, see:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.a,{href:"/Physical-AI-Humanoid-Robotics/docs/week-1-2/introduction-to-physical-ai",children:"Introduction to Physical AI"})," - For foundational concepts"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.a,{href:"/Physical-AI-Humanoid-Robotics/docs/week-3-5/ros2-architecture",children:"ROS 2 Architecture and Core Concepts"})," - For robot software frameworks"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.a,{href:"/Physical-AI-Humanoid-Robotics/docs/week-6-7/gazebo-setup",children:"Gazebo simulation environment setup"})," - For simulating humanoid robots"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.a,{href:"/Physical-AI-Humanoid-Robotics/docs/week-8-10/isaac-sdk-sim",children:"NVIDIA Isaac SDK and Isaac Sim"})," - For advanced simulation platforms"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.a,{href:"/Physical-AI-Humanoid-Robotics/docs/week-11-12/bipedal-locomotion",children:"Bipedal locomotion and balance control"})," - For detailed walking control"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.a,{href:"/Physical-AI-Humanoid-Robotics/docs/week-11-12/manipulation-grasping",children:"Manipulation and grasping with humanoid hands"})," - For manipulation kinematics"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.a,{href:"/Physical-AI-Humanoid-Robotics/docs/week-11-12/human-robot-interaction",children:"Natural human-robot interaction design"})," - For interaction aspects"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.a,{href:"/Physical-AI-Humanoid-Robotics/docs/capstone-project",children:"Capstone project requirements"})," - For implementing complete humanoid systems"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,a.jsx)(e.p,{children:"Refer to the following code examples in the textbook repository:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"docs/static/code-examples/capstone/humanoid_capstone_template.py"})," - Template for humanoid robot integration"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Implement forward kinematics for a simplified humanoid arm with 6 DOF"}),"\n",(0,a.jsx)(e.li,{children:"Solve inverse kinematics for a target position using numerical methods"}),"\n",(0,a.jsx)(e.li,{children:"Calculate the center of mass for a simple humanoid model"}),"\n",(0,a.jsx)(e.li,{children:"Generate a walking pattern using the inverted pendulum model"}),"\n",(0,a.jsx)(e.li,{children:"Create a simulation of a humanoid robot maintaining balance"}),"\n"]})]})}function m(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>r});var o=i(6540);const a={},t=o.createContext(a);function s(n){const e=o.useContext(t);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:s(n.components),o.createElement(t.Provider,{value:e},n.children)}}}]);