"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[347],{3866:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"week-11-12/manipulation-grasping","title":"Manipulation and Grasping with Humanoid Hands","description":"Humanoid manipulation involves complex coordination of multiple degrees of freedom to perform dexterous tasks. This section covers the principles of robotic manipulation, grasping strategies, and control techniques specific to humanoid robots with anthropomorphic hands.","source":"@site/docs/week-11-12/manipulation-grasping.md","sourceDirName":"week-11-12","slug":"/week-11-12/manipulation-grasping","permalink":"/Physical-AI-Humanoid-Robotics/docs/week-11-12/manipulation-grasping","draft":false,"unlisted":false,"editUrl":"https://github.com/Muhammadtalha678/Physical-AI-Humanoid-Robotics/edit/main/docs/docs/week-11-12/manipulation-grasping.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Manipulation and Grasping with Humanoid Hands"},"sidebar":"tutorialSidebar","previous":{"title":"Bipedal Locomotion and Balance Control","permalink":"/Physical-AI-Humanoid-Robotics/docs/week-11-12/bipedal-locomotion"},"next":{"title":"Natural Human-Robot Interaction Design","permalink":"/Physical-AI-Humanoid-Robotics/docs/week-11-12/human-robot-interaction"}}');var s=a(4848),t=a(8453);const i={sidebar_position:3,title:"Manipulation and Grasping with Humanoid Hands"},o="Manipulation and Grasping with Humanoid Hands",l={},c=[{value:"Introduction to Humanoid Manipulation",id:"introduction-to-humanoid-manipulation",level:2},{value:"Degrees of Freedom and Workspace",id:"degrees-of-freedom-and-workspace",level:3},{value:"Anthropomorphic Hand Design",id:"anthropomorphic-hand-design",level:3},{value:"Grasp Planning and Analysis",id:"grasp-planning-and-analysis",level:2},{value:"Grasp Types",id:"grasp-types",level:3},{value:"Grasp Stability Analysis",id:"grasp-stability-analysis",level:3},{value:"Dexterous Manipulation",id:"dexterous-manipulation",level:2},{value:"In-Hand Manipulation",id:"in-hand-manipulation",level:3},{value:"Multi-Finger Coordination",id:"multi-finger-coordination",level:3},{value:"Control Strategies for Manipulation",id:"control-strategies-for-manipulation",level:2},{value:"Impedance Control",id:"impedance-control",level:3},{value:"Force Control",id:"force-control",level:3},{value:"Tactile Sensing and Feedback",id:"tactile-sensing-and-feedback",level:2},{value:"Tactile Sensor Integration",id:"tactile-sensor-integration",level:3},{value:"Learning-Based Manipulation",id:"learning-based-manipulation",level:2},{value:"Imitation Learning for Grasping",id:"imitation-learning-for-grasping",level:3},{value:"Reinforcement Learning for Manipulation",id:"reinforcement-learning-for-manipulation",level:3},{value:"Humanoid-Specific Challenges",id:"humanoid-specific-challenges",level:2},{value:"Whole-Body Coordination",id:"whole-body-coordination",level:3},{value:"Bilateral Manipulation",id:"bilateral-manipulation",level:3},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Code Examples",id:"code-examples",level:2},{value:"Exercises",id:"exercises",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"manipulation-and-grasping-with-humanoid-hands",children:"Manipulation and Grasping with Humanoid Hands"})}),"\n",(0,s.jsx)(n.p,{children:"Humanoid manipulation involves complex coordination of multiple degrees of freedom to perform dexterous tasks. This section covers the principles of robotic manipulation, grasping strategies, and control techniques specific to humanoid robots with anthropomorphic hands."}),"\n",(0,s.jsx)(n.h2,{id:"introduction-to-humanoid-manipulation",children:"Introduction to Humanoid Manipulation"}),"\n",(0,s.jsx)(n.h3,{id:"degrees-of-freedom-and-workspace",children:"Degrees of Freedom and Workspace"}),"\n",(0,s.jsx)(n.p,{children:"Humanoid robots typically have 7-8 degrees of freedom per arm, providing redundant solutions for reaching tasks. The human hand has 20+ degrees of freedom, making dexterous manipulation particularly challenging."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import numpy as np\nfrom scipy.spatial.transform import Rotation as R\n\nclass HumanoidArm:\n    def __init__(self):\n        # Typical humanoid arm with 7 DOF\n        self.joint_limits = np.array([\n            [-2.0, 2.0],   # Shoulder yaw\n            [-1.5, 1.5],   # Shoulder pitch\n            [-3.0, 1.0],   # Shoulder roll\n            [-2.0, 2.0],   # Elbow pitch\n            [-2.0, 2.0],   # Forearm yaw\n            [-1.5, 2.0],   # Wrist pitch\n            [-2.0, 2.0]    # Wrist roll\n        ])\n\n        self.link_lengths = [0.15, 0.3, 0.3, 0.05]  # Simplified arm segments\n\n    def forward_kinematics(self, joint_angles):\n        """\n        Calculate forward kinematics for the arm\n        """\n        # Simplified implementation - in practice this would involve\n        # complex transformation matrices\n        position = np.zeros(3)\n        rotation = R.from_euler(\'xyz\', [0, 0, 0])\n\n        # Calculate transformations for each joint\n        for i, angle in enumerate(joint_angles):\n            # This is a simplified representation\n            # Real implementation would use DH parameters or other methods\n            pass\n\n        return position, rotation\n'})}),"\n",(0,s.jsx)(n.h3,{id:"anthropomorphic-hand-design",children:"Anthropomorphic Hand Design"}),"\n",(0,s.jsx)(n.p,{children:"Humanoid hands are designed to mimic human hand capabilities:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Opposable thumb"}),": Enables precision grasps"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multiple fingers"}),": Provide multiple contact points"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Tactile sensing"}),": Feedback for grasp stability"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Underactuation"}),": Often use fewer actuators than DOF"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"grasp-planning-and-analysis",children:"Grasp Planning and Analysis"}),"\n",(0,s.jsx)(n.h3,{id:"grasp-types",children:"Grasp Types"}),"\n",(0,s.jsx)(n.p,{children:"Humanoid robots can perform various grasp types:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Power Grasps"}),": For lifting and carrying heavy objects"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Precision Grasps"}),": For fine manipulation tasks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Pinch Grasps"}),": Using thumb and one finger"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Lateral Grasps"}),": Using thumb and side of index finger"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class GraspPlanner:\n    def __init__(self):\n        self.grasp_types = {\n            'cylindrical': self.plan_cylindrical_grasp,\n            'spherical': self.plan_spherical_grasp,\n            'lateral': self.plan_lateral_grasp,\n            'tip': self.plan_tip_grasp\n        }\n\n    def plan_grasp(self, object_shape, object_size, grasp_type='cylindrical'):\n        \"\"\"\n        Plan a grasp based on object properties and desired grasp type\n        \"\"\"\n        if grasp_type in self.grasp_types:\n            return self.grasp_types[grasp_type](object_shape, object_size)\n        else:\n            raise ValueError(f\"Unknown grasp type: {grasp_type}\")\n\n    def plan_cylindrical_grasp(self, object_shape, object_size):\n        \"\"\"\n        Plan a cylindrical grasp for a cylindrical object\n        \"\"\"\n        # Find optimal grasp points around the cylinder\n        grasp_points = []\n\n        # Calculate grasp positions\n        radius = object_size[0] / 2  # Assuming first dimension is diameter\n        height = object_size[1]      # Assuming second dimension is height\n\n        # Calculate grasp positions on opposite sides\n        grasp_pos1 = np.array([0, radius, height/2])\n        grasp_pos2 = np.array([0, -radius, height/2])\n\n        # Calculate grasp orientations\n        grasp_orient1 = R.from_euler('xyz', [0, 0, np.pi/2]).as_matrix()\n        grasp_orient2 = R.from_euler('xyz', [0, 0, -np.pi/2]).as_matrix()\n\n        return {\n            'grasp_points': [grasp_pos1, grasp_pos2],\n            'orientations': [grasp_orient1, grasp_orient2],\n            'grasp_type': 'cylindrical'\n        }\n"})}),"\n",(0,s.jsx)(n.h3,{id:"grasp-stability-analysis",children:"Grasp Stability Analysis"}),"\n",(0,s.jsx)(n.p,{children:"Analyzing whether a grasp will be stable:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def calculate_grasp_quality(grasp_points, object_com, contact_forces, friction_coeff=0.8):\n    """\n    Calculate grasp quality based on contact points and forces\n    """\n    # Calculate grasp matrix\n    G = np.zeros((6, len(grasp_points) * 3))  # 6 DOF, 3 forces per contact\n\n    for i, (point, force) in enumerate(zip(grasp_points, contact_forces)):\n        # Position vector from object COM to contact point\n        r = point - object_com\n\n        # Grasp matrix row for this contact\n        G[0:3, i*3:(i+1)*3] = np.eye(3)  # Forces\n        G[3:6, i*3:(i+1)*3] = np.cross(r, np.eye(3))  # Torques\n\n    # Calculate grasp quality metric (condition number of grasp matrix)\n    U, s, Vt = np.linalg.svd(G)\n    quality = np.min(s) / np.max(s) if np.max(s) > 0 else 0\n\n    return quality\n\ndef check_grasp_stability(object_mass, grasp_points, contact_forces, gravity=9.81):\n    """\n    Check if the grasp can support the object against gravity\n    """\n    # Calculate total upward force\n    total_upward_force = sum(f[2] for f in contact_forces)  # Assuming z is up\n\n    # Required force to support object\n    required_force = object_mass * gravity\n\n    return total_upward_force >= required_force\n'})}),"\n",(0,s.jsx)(n.h2,{id:"dexterous-manipulation",children:"Dexterous Manipulation"}),"\n",(0,s.jsx)(n.h3,{id:"in-hand-manipulation",children:"In-Hand Manipulation"}),"\n",(0,s.jsx)(n.p,{children:"Moving objects within the hand without releasing:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class InHandManipulator:\n    def __init__(self, hand_model):\n        self.hand_model = hand_model\n\n    def roll_object(self, object_pose, target_pose, finger_positions):\n        """\n        Roll an object from current pose to target pose\n        """\n        # Calculate required finger movements to roll object\n        pose_diff = target_pose - object_pose\n        finger_commands = self.calculate_finger_trajectories(\n            pose_diff, finger_positions\n        )\n\n        return finger_commands\n\n    def reposition_grasp(self, current_grasp, target_grasp):\n        """\n        Reposition the grasp without releasing the object\n        """\n        # Plan a sequence of finger movements to change grasp configuration\n        movement_sequence = []\n\n        # Calculate intermediate grasp configurations\n        for i in range(10):  # 10 intermediate steps\n            t = i / 10.0\n            intermediate_grasp = self.interpolate_grasps(\n                current_grasp, target_grasp, t\n            )\n            movement_sequence.append(intermediate_grasp)\n\n        return movement_sequence\n\n    def interpolate_grasps(self, grasp1, grasp2, t):\n        """\n        Interpolate between two grasp configurations\n        """\n        interpolated = {}\n        for key in grasp1.keys():\n            if isinstance(grasp1[key], np.ndarray):\n                interpolated[key] = grasp1[key] * (1-t) + grasp2[key] * t\n            else:\n                interpolated[key] = grasp1[key]\n        return interpolated\n'})}),"\n",(0,s.jsx)(n.h3,{id:"multi-finger-coordination",children:"Multi-Finger Coordination"}),"\n",(0,s.jsx)(n.p,{children:"Coordinating multiple fingers for complex tasks:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class MultiFingerController:\n    def __init__(self, num_fingers=5):\n        self.num_fingers = num_fingers\n        self.finger_controllers = [FingerController(i) for i in range(num_fingers)]\n\n    def coordinate_fingers(self, task, object_properties):\n        \"\"\"\n        Coordinate fingers for a specific manipulation task\n        \"\"\"\n        # Determine finger roles based on task\n        finger_roles = self.assign_finger_roles(task, object_properties)\n\n        # Generate individual finger commands\n        finger_commands = []\n        for i, role in enumerate(finger_roles):\n            command = self.finger_controllers[i].execute_role(role, object_properties)\n            finger_commands.append(command)\n\n        return finger_commands\n\n    def assign_finger_roles(self, task, object_properties):\n        \"\"\"\n        Assign roles to fingers based on task requirements\n        \"\"\"\n        roles = ['thumb']  # Always assign thumb role first\n\n        if task == 'cylindrical_grasp':\n            roles.extend(['oppose', 'support', 'support', 'support'])\n        elif task == 'tip_grasp':\n            roles.extend(['index', 'middle', 'none', 'none'])\n        elif task == 'large_object':\n            roles.extend(['index', 'middle', 'ring', 'pinky'])\n        else:\n            roles.extend(['support'] * (self.num_fingers - 1))\n\n        return roles\n"})}),"\n",(0,s.jsx)(n.h2,{id:"control-strategies-for-manipulation",children:"Control Strategies for Manipulation"}),"\n",(0,s.jsx)(n.h3,{id:"impedance-control",children:"Impedance Control"}),"\n",(0,s.jsx)(n.p,{children:"Impedance control allows for compliant manipulation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class ImpedanceController:\n    def __init__(self, stiffness=1000, damping=200, mass=1):\n        self.stiffness = stiffness\n        self.damping = damping\n        self.mass = mass\n\n    def calculate_impedance_force(self, position_error, velocity_error):\n        """\n        Calculate force based on impedance model\n        """\n        spring_force = self.stiffness * position_error\n        damper_force = self.damping * velocity_error\n        total_force = spring_force + damper_force\n\n        return total_force\n\n    def adapt_impedance(self, task_phase):\n        """\n        Adapt impedance based on task requirements\n        """\n        if task_phase == \'approach\':\n            # Low stiffness for safe approach\n            self.stiffness = 100\n        elif task_phase == \'grasp\':\n            # High stiffness for firm grasp\n            self.stiffness = 2000\n        elif task_phase == \'manipulate\':\n            # Variable stiffness based on task\n            self.stiffness = 1000\n        elif task_phase == \'release\':\n            # Low stiffness to avoid damage\n            self.stiffness = 100\n'})}),"\n",(0,s.jsx)(n.h3,{id:"force-control",children:"Force Control"}),"\n",(0,s.jsx)(n.p,{children:"Force control is essential for safe manipulation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class ForceController:\n    def __init__(self, desired_force, force_tolerance=5.0):\n        self.desired_force = desired_force\n        self.force_tolerance = force_tolerance\n        self.integral_error = 0\n        self.previous_error = 0\n\n    def update_force_control(self, measured_force, dt):\n        """\n        Update force control based on measured force\n        """\n        error = self.desired_force - measured_force\n        self.integral_error += error * dt\n        derivative_error = (error - self.previous_error) / dt if dt > 0 else 0\n\n        # PID control\n        kp, ki, kd = 1.0, 0.1, 0.05\n        control_output = kp * error + ki * self.integral_error + kd * derivative_error\n\n        self.previous_error = error\n\n        return control_output\n\n    def adjust_contact_force(self, desired_contact_force, current_contact_force):\n        """\n        Adjust contact force to desired level\n        """\n        force_error = desired_contact_force - current_contact_force\n\n        if abs(force_error) > self.force_tolerance:\n            # Adjust position to achieve desired force\n            position_adjustment = 0.001 * np.sign(force_error)  # 1mm per 1N error\n            return position_adjustment\n        else:\n            return 0.0  # No adjustment needed\n'})}),"\n",(0,s.jsx)(n.h2,{id:"tactile-sensing-and-feedback",children:"Tactile Sensing and Feedback"}),"\n",(0,s.jsx)(n.h3,{id:"tactile-sensor-integration",children:"Tactile Sensor Integration"}),"\n",(0,s.jsx)(n.p,{children:"Tactile feedback is crucial for dexterous manipulation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class TactileFeedbackSystem:\n    def __init__(self, num_sensors=20):\n        self.num_sensors = num_sensors\n        self.sensor_threshold = 0.1  # Minimum pressure to register contact\n        self.pressure_map = np.zeros(num_sensors)\n\n    def process_tactile_data(self, raw_sensor_data):\n        """\n        Process raw tactile sensor data\n        """\n        # Convert raw data to pressure values\n        pressure_values = self.convert_raw_to_pressure(raw_sensor_data)\n\n        # Update pressure map\n        self.pressure_map = pressure_values\n\n        # Detect contact events\n        contact_events = self.detect_contacts(pressure_values)\n\n        return pressure_values, contact_events\n\n    def detect_slip(self, current_pressures, previous_pressures, time_diff):\n        """\n        Detect potential slip based on pressure changes\n        """\n        pressure_changes = current_pressures - previous_pressures\n\n        # High pressure change rate may indicate slip\n        slip_indicators = np.abs(pressure_changes) / time_diff\n\n        return slip_indicators > 100  # Threshold for slip detection\n\n    def adjust_grasp(self, slip_detected):\n        """\n        Adjust grasp if slip is detected\n        """\n        if np.any(slip_detected):\n            # Increase grasp force\n            force_increase = 5.0  # 5N increase\n            return force_increase\n        else:\n            return 0.0\n'})}),"\n",(0,s.jsx)(n.h2,{id:"learning-based-manipulation",children:"Learning-Based Manipulation"}),"\n",(0,s.jsx)(n.h3,{id:"imitation-learning-for-grasping",children:"Imitation Learning for Grasping"}),"\n",(0,s.jsx)(n.p,{children:"Learning from human demonstrations:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class ImitationLearningGrasper:\n    def __init__(self):\n        self.demonstration_database = []\n        self.feature_extractor = FeatureExtractor()\n        self.policy_network = PolicyNetwork()\n\n    def add_demonstration(self, state_sequence, action_sequence):\n        """\n        Add a successful grasp demonstration to the database\n        """\n        demonstration = {\n            \'states\': state_sequence,\n            \'actions\': action_sequence,\n            \'success\': True\n        }\n        self.demonstration_database.append(demonstration)\n\n    def learn_grasp_policy(self):\n        """\n        Learn a grasp policy from demonstrations\n        """\n        # Extract features from demonstrations\n        states = []\n        actions = []\n\n        for demo in self.demonstration_database:\n            for state, action in zip(demo[\'states\'], demo[\'actions\']):\n                states.append(self.feature_extractor.extract(state))\n                actions.append(action)\n\n        # Train policy network\n        self.policy_network.train(np.array(states), np.array(actions))\n\n    def execute_grasp(self, current_state):\n        """\n        Execute grasp based on learned policy\n        """\n        features = self.feature_extractor.extract(current_state)\n        action = self.policy_network.predict(features)\n        return action\n'})}),"\n",(0,s.jsx)(n.h3,{id:"reinforcement-learning-for-manipulation",children:"Reinforcement Learning for Manipulation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class RLManipulator:\n    def __init__(self, state_dim, action_dim):\n        self.state_dim = state_dim\n        self.action_dim = action_dim\n        self.q_network = QNetwork(state_dim, action_dim)\n        self.target_network = QNetwork(state_dim, action_dim)\n        self.replay_buffer = ReplayBuffer()\n\n    def calculate_reward(self, state, action, next_state):\n        """\n        Calculate reward for manipulation task\n        """\n        reward = 0\n\n        # Grasp stability reward\n        if self.is_stable_grasp(next_state):\n            reward += 10\n\n        # Object position reward (closer to target)\n        obj_pos = next_state[\'object_position\']\n        target_pos = next_state[\'target_position\']\n        dist_to_target = np.linalg.norm(obj_pos - target_pos)\n        reward -= dist_to_target  # Negative distance reward\n\n        # Penalty for excessive force\n        if self.is_excessive_force(next_state):\n            reward -= 5\n\n        return reward\n\n    def is_stable_grasp(self, state):\n        """\n        Check if the current grasp is stable\n        """\n        # Check if object is still in hand\n        if not state[\'object_in_hand\']:\n            return False\n\n        # Check if grasp forces are within reasonable bounds\n        grasp_forces = state[\'grasp_forces\']\n        if np.any(grasp_forces > 50):  # 50N max per finger\n            return False\n\n        return True\n'})}),"\n",(0,s.jsx)(n.h2,{id:"humanoid-specific-challenges",children:"Humanoid-Specific Challenges"}),"\n",(0,s.jsx)(n.h3,{id:"whole-body-coordination",children:"Whole-Body Coordination"}),"\n",(0,s.jsx)(n.p,{children:"Humanoid manipulation requires coordination of the entire body:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class WholeBodyManipulator:\n    def __init__(self):\n        self.arm_controller = ArmController()\n        self.balance_controller = BalanceController()\n        self.gaze_controller = GazeController()\n\n    def coordinated_manipulation(self, task, object_pose, robot_state):\n        """\n        Perform manipulation with whole-body coordination\n        """\n        # Plan manipulation trajectory\n        manipulation_plan = self.plan_manipulation(task, object_pose)\n\n        # Adjust balance for manipulation\n        balance_adjustment = self.calculate_balance_adjustment(\n            manipulation_plan, robot_state\n        )\n\n        # Control gaze to track object\n        gaze_command = self.calculate_gaze_command(object_pose)\n\n        # Execute coordinated movement\n        arm_command = self.arm_controller.execute_plan(manipulation_plan)\n\n        return arm_command, balance_adjustment, gaze_command\n\n    def calculate_balance_adjustment(self, manipulation_plan, robot_state):\n        """\n        Calculate balance adjustments needed for manipulation\n        """\n        # Predict center of mass shift due to manipulation\n        predicted_com_shift = self.predict_com_shift(manipulation_plan)\n\n        # Calculate required balance adjustments\n        balance_command = self.balance_controller.calculate_balance_correction(\n            robot_state[\'com\'] + predicted_com_shift,\n            robot_state[\'com_reference\'],\n            robot_state[\'com_velocity\']\n        )\n\n        return balance_command\n'})}),"\n",(0,s.jsx)(n.h3,{id:"bilateral-manipulation",children:"Bilateral Manipulation"}),"\n",(0,s.jsx)(n.p,{children:"Using both arms for complex tasks:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class BilateralManipulator:\n    def __init__(self):\n        self.left_arm = ArmController('left')\n        self.right_arm = ArmController('right')\n        self.coordinator = CoordinationController()\n\n    def bimanual_task(self, task_description, object_poses):\n        \"\"\"\n        Execute bimanual manipulation task\n        \"\"\"\n        # Plan left and right arm trajectories\n        left_plan = self.plan_left_arm_task(task_description, object_poses)\n        right_plan = self.plan_right_arm_task(task_description, object_poses)\n\n        # Coordinate both arms\n        coordinated_plan = self.coordinator.coordinate_plans(left_plan, right_plan)\n\n        # Execute in coordination\n        left_command = self.left_arm.execute_plan(coordinated_plan['left'])\n        right_command = self.right_arm.execute_plan(coordinated_plan['right'])\n\n        return left_command, right_command\n\n    def plan_left_arm_task(self, task, objects):\n        \"\"\"\n        Plan left arm task based on overall task description\n        \"\"\"\n        if task == 'pass_object':\n            # Left arm receives object\n            return self.plan_reach_and_grasp(objects['object_to_receive'])\n        elif task == 'assemble':\n            # Left arm holds base object\n            return self.plan_stabilize_object(objects['base_object'])\n        else:\n            return self.plan_default_task()\n\n    def plan_right_arm_task(self, task, objects):\n        \"\"\"\n        Plan right arm task based on overall task description\n        \"\"\"\n        if task == 'pass_object':\n            # Right arm passes object\n            return self.plan_release_object(objects['object_to_pass'])\n        elif task == 'assemble':\n            # Right arm manipulates parts\n            return self.plan_assemble_parts(objects['parts'])\n        else:\n            return self.plan_default_task()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(n.p,{children:"After completing this section, you should be able to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Understand the kinematics and dynamics of humanoid manipulation"}),"\n",(0,s.jsx)(n.li,{children:"Plan stable grasps for various object types"}),"\n",(0,s.jsx)(n.li,{children:"Implement impedance and force control for safe manipulation"}),"\n",(0,s.jsx)(n.li,{children:"Integrate tactile sensing for dexterous manipulation"}),"\n",(0,s.jsx)(n.li,{children:"Coordinate whole-body motion for manipulation tasks"}),"\n",(0,s.jsx)(n.li,{children:"Apply learning techniques to improve manipulation skills"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,s.jsx)(n.p,{children:"Refer to the following code examples in the textbook repository:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"docs/static/code-examples/capstone/humanoid_capstone_template.py"})," - Template for humanoid robot integration"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Implement a grasp planner for cylindrical objects"}),"\n",(0,s.jsx)(n.li,{children:"Create an impedance controller for safe manipulation"}),"\n",(0,s.jsx)(n.li,{children:"Design a tactile feedback system for grasp stability"}),"\n",(0,s.jsx)(n.li,{children:"Implement a bimanual coordination controller"}),"\n",(0,s.jsx)(n.li,{children:"Develop a whole-body manipulation system for the humanoid"}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>o});var r=a(6540);const s={},t=r.createContext(s);function i(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);